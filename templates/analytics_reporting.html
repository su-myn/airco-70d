{% extends "base.html" %}

{% block title %}Analytics & Reporting - PropertyHub{% endblock %}

{% block additional_styles %}
<style>
    .analytics-container {
        background-color: white;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        padding: 20px;
        margin-bottom: 30px;
    }

    .analytics-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
    }

    .analytics-title {
        font-size: 1.5rem;
        font-weight: bold;
        margin: 0;
    }

    .chart-container {
        height: 400px;
        margin-bottom: 30px;
    }

    .filters-container {
        display: flex;
        flex-wrap: wrap;
        gap: 15px;
        margin-bottom: 20px;
        padding: 15px;
        background-color: #f8f9fa;
        border-radius: 8px;
    }

    .filter-group {
        display: flex;
        flex-direction: column;
        min-width: 200px;
    }

    .filter-group label {
        margin-bottom: 5px;
        font-weight: bold;
    }

    .filter-group select {
        padding: 8px;
        border-radius: 4px;
        border: 1px solid #ddd;
    }

    .filter-actions {
        display: flex;
        gap: 10px;
        align-self: flex-end;
        margin-top: 23px;
    }

    .filter-btn {
        padding: 8px 15px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
    }

    .apply-btn {
        background-color: #ee4d2d;
        color: white;
    }

    .reset-btn {
        background-color: #6c757d;
        color: white;
    }

    .stats-cards {
        display: flex;
        flex-wrap: wrap;
        gap: 20px;
        margin-bottom: 30px;
    }

    .stat-card {
        background-color: #f8f9fa;
        border-radius: 8px;
        padding: 15px;
        min-width: 200px;
        flex: 1;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
    }

    .stat-value {
        font-size: 2rem;
        font-weight: bold;
        color: #ee4d2d;
    }

    .stat-label {
        color: #6c757d;
        font-size: 0.9rem;
    }

    .chart-tabs {
        display: flex;
        gap: 10px;
        margin-bottom: 15px;
        border-bottom: 1px solid #ddd;
    }

    .chart-tab {
        padding: 10px 15px;
        cursor: pointer;
        border-bottom: 3px solid transparent;
    }

    .chart-tab.active {
        border-bottom-color: #ee4d2d;
        font-weight: bold;
    }

    .tab-content {
        display: none;
    }

    .tab-content.active {
        display: block;
    }

    /* Responsive */
    @media (max-width: 768px) {
        .filters-container {
            flex-direction: column;
        }

        .filter-group {
            width: 100%;
        }

        .chart-tabs {
            flex-wrap: wrap;
        }

        .chart-container {
            height: 300px;
        }
    }
</style>
{% endblock %}

{% block content %}
<div class="analytics-container">
    <div class="analytics-header">
        <h2 class="analytics-title">Analytics & Reporting</h2>
    </div>

    <div class="filters-container">
        <div class="filter-group">
            <label for="date-range">Date Range</label>
            <select id="date-range">
                <option value="all">All Time</option>
                <option value="hour">Last 1 Hour</option>
                <option value="today">Today</option>
                <option value="yesterday">Yesterday</option>
                <option value="7">Last 7 Days</option>
                <option value="30">Last 30 Days</option>
                <option value="90">Last 90 Days</option>
                <option value="180">Last 6 Months</option>
                <option value="365">Last 12 Months</option>
            </select>
        </div>

        <div class="filter-group">
            <label for="category-filter">Category</label>
            <select id="category-filter">
                <option value="all">All Categories</option>
                {% for category in categories %}
                <option value="{{ category.id }}">{{ category.name }}</option>
                {% endfor %}
            </select>
        </div>

        <div class="filter-group">
            <label for="priority-filter">Priority</label>
            <select id="priority-filter">
                <option value="all">All Priorities</option>
                {% for priority in priorities %}
                <option value="{{ priority.id }}">{{ priority.name }}</option>
                {% endfor %}
            </select>
        </div>

        <div class="filter-group">
            <label for="status-filter">Status</label>
            <select id="status-filter">
                <option value="all">All Statuses</option>
                {% for status in statuses %}
                <option value="{{ status.id }}">{{ status.name }}</option>
                {% endfor %}
            </select>
        </div>

        <div class="filter-group">
            <label for="unit-filter">Unit</label>
            <select id="unit-filter">
                <option value="all">All Units</option>
                {% for unit in units %}
                <option value="{{ unit.unit_number }}">{{ unit.unit_number }}</option>
                {% endfor %}
            </select>
        </div>

        <div class="filter-actions">
            <button id="apply-filters" class="filter-btn apply-btn">Apply Filters</button>
            <button id="reset-filters" class="filter-btn reset-btn">Reset</button>
        </div>
    </div>

    <div class="stats-cards">
        <div class="stat-card">
            <div class="stat-value" id="total-issues">0</div>
            <div class="stat-label">Total Issues</div>
        </div>
        <div class="stat-card">
            <div class="stat-value" id="open-issues">0</div>
            <div class="stat-label">Open Issues</div>
        </div>
        <div class="stat-card">
            <div class="stat-value" id="resolved-issues">0</div>
            <div class="stat-label">Resolved Issues</div>
        </div>
        <div class="stat-card">
            <div class="stat-value" id="total-cost">RM0.00</div>
            <div class="stat-label">Total Cost</div>
        </div>
    </div>

    <div class="chart-tabs">
        <div class="chart-tab active" data-tab="issues-by-status">Issues by Status</div>
        <div class="chart-tab " data-tab="issues-over-time">Issues Over Time</div>
        <div class="chart-tab" data-tab="issues-by-category">Issues by Category</div>
        <div class="chart-tab" data-tab="issues-by-priority">Issues by Priority</div>
        <div class="chart-tab" data-tab="cost-analysis">Cost Analysis</div>
        <div class="chart-tab" data-tab="unit-heatmap">Unit</div>
        <div class="chart-tab" data-tab="replacement-item">Replacement Item</div>
    </div>

    <div class="tab-content active" id="issues-by-status-content">
        <!--<div class="chart-container" id="issues-by-status-chart"></div>
        -->
        <div class="chart-container">
            <canvas id="issues-by-status-chart"></canvas>
        </div>
    </div>

    <div class="tab-content" id="issues-over-time-content">
        <!-- Today's Issues Chart -->
        <h4 style="margin-top: 10px; margin-bottom: 15px; font-weight: 500; color: #333;">Issues Today by Hour</h4>
        <div class="chart-container">
            <canvas id="issues-today-chart"></canvas>
        </div>

        <hr style="margin: 30px 0; border-color: #eee;">

        <!-- Monthly Issues Chart -->
        <h4 style="margin-top: 10px; margin-bottom: 15px; font-weight: 500; color: #333;">Issues Trend by Month</h4>
        <div class="chart-container">
            <canvas id="issues-over-time-chart"></canvas>
        </div>
    </div>

    <div class="tab-content" id="issues-by-category-content">
        <div class="chart-container">
            <canvas id="issues-by-category-chart"></canvas>
        </div>

        <hr style="margin: 30px 0; border-color: #eee;">

        <h4 style="margin-top: 10px; margin-bottom: 15px; font-weight: 500; color: #333;">Top Issue Types</h4>
        <div class="chart-container" style="height: 350px;">
            <canvas id="issue-types-chart"></canvas>
        </div>
    </div>

    <div class="tab-content" id="issues-by-priority-content">
        <!--<div class="chart-container" id="issues-by-priority-chart"></div>
        -->
        <div class="chart-container">
            <canvas id="issues-by-priority-chart"></canvas>
        </div>
    </div>

    <div class="tab-content" id="cost-analysis-content">
        <!--<div class="chart-container" id="cost-analysis-chart"></div>
        -->
        <div class="chart-container">
            <canvas id="cost-analysis-chart"></canvas>
        </div>

        <hr style="margin: 30px 0; border-color: #eee;">

        <h4 style="margin-top: 10px; margin-bottom: 15px; font-weight: 500; color: #333;">Top Units by Cost</h4>
        <div class="chart-container">
            <canvas id="units-by-cost-chart"></canvas>
        </div>
    </div>

    <div class="tab-content" id="unit-heatmap-content">
        <h4 style="margin-top: 10px; margin-bottom: 15px; font-weight: 500; color: #333;">Issues Heatmap by Unit and Category</h4>
        <div class="chart-container" style="height: 600px; position: relative;">
            <canvas id="unit-heatmap-chart"></canvas>
        </div>
    </div>

    <!-- Add this to the chart-tabs div, after the last existing tab -->
    <div class="chart-tab" data-tab="replacement-item">Replacement Item</div>

    <!-- Add this tab content div at the end of your tab content sections -->
    <div class="tab-content" id="replacement-item-content">
        <div class="filters-container" style="flex-wrap: nowrap;">
            <div class="filter-group">
                <label for="replacement-time-period">Time Period</label>
                <select id="replacement-time-period">
                    <option value="all">All Time</option>
                    <option value="hour">Last 1 Hour</option>
                    <option value="today">Today</option>
                    <option value="yesterday">Yesterday</option>
                    <option value="7">Last 7 Days</option>
                    <option value="30">Last 30 Days</option>
                    <option value="90">Last 90 Days</option>
                    <option value="180">Last 6 Months</option>
                    <option value="365">Last 1 Year</option>
                </select>
            </div>

            <div class="filter-group">
                <label for="replacement-unit">Unit</label>
                <select id="replacement-unit">
                    <option value="all">All Units</option>
                </select>
            </div>

            <div class="filter-group">
                <label for="replacement-category">Category</label>
                <select id="replacement-category">
                    <option value="all">All Categories</option>
                </select>
            </div>

            <div class="filter-actions">
                <button id="apply-replacement-filters" class="filter-btn apply-btn">Apply</button>
                <button id="reset-replacement-filters" class="filter-btn reset-btn">Reset</button>
            </div>
        </div>

        <div class="analytics-cards" style="margin-top: 20px;">
            <div class="analytics-card card-cost">
                <h3 id="total-replacement-cost">RM0.00</h3>
                <div class="stat-label">Total Replacement Cost</div>
            </div>
            <div class="analytics-card card-total">
                <h3 id="total-replacement-items">0</h3>
                <div class="stat-label">Total Replacement Items</div>
            </div>
        </div>

        <div style="display: flex; flex-wrap: wrap; gap: 20px; margin-top: 20px;">
            <div style="flex: 1; min-width: 300px;">
                <h4 style="margin-top: 10px; margin-bottom: 15px; font-weight: 500; color: #333;">Replacement Items by Type</h4>
                <div class="chart-container" style="height: 350px; position: relative;">
                    <canvas id="replacement-pie-chart"></canvas>
                </div>
            </div>
            <div style="flex: 1; min-width: 300px;">
                <h4 style="margin-top: 10px; margin-bottom: 15px; font-weight: 500; color: #333;">Replacement Item Distribution</h4>
                <div class="chart-container" style="height: 350px; position: relative;">
                    <canvas id="replacement-treemap-chart"></canvas>
                </div>
            </div>
        </div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
<script>
    // Global chart instances (for destroying and recreating)
    let timeChart, todayChart, categoryChart, priorityChart, statusChart, costChart, issueTypesChart, unitHeatmapChart;
    // Demo data - will be replaced by API data
    let issuesData = [];

    // DOM ready
    document.addEventListener('DOMContentLoaded', function() {
        // Fetch issues data from API
        fetchIssuesData();

        // Tab switching
        document.querySelectorAll('.chart-tab').forEach(tab => {
            tab.addEventListener('click', function() {
                document.querySelectorAll('.chart-tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

                this.classList.add('active');

                const tabId = this.getAttribute('data-tab');
                document.getElementById(`${tabId}-content`).classList.add('active');
            });
        });

        // Filter events
        document.getElementById('apply-filters').addEventListener('click', applyFilters);
        document.getElementById('reset-filters').addEventListener('click', resetFilters);
    });

    function fetchIssuesData() {
        // Get issues data from API
        fetch('/api/analytics/issues')
            .then(response => response.json())
            .then(data => {
                issuesData = data;
                updateDashboard(issuesData);
            })
            .catch(error => console.error('Error fetching issues data:', error));
    }

    function applyFilters() {
        const dateRange = document.getElementById('date-range').value;
        const categoryId = document.getElementById('category-filter').value;
        const priorityId = document.getElementById('priority-filter').value;
        const statusId = document.getElementById('status-filter').value;
        const unitFilter = document.getElementById('unit-filter').value;

        // Build query parameters
        let params = new URLSearchParams();

        // Handle different date ranges with corrected calendar-based logic
        if (dateRange !== 'all') {
            if (dateRange === 'hour') {
                // Last 1 hour
                params.append('time_filter', 'hour');
            } else if (dateRange === 'today') {
                // Today (calendar day)
                params.append('time_filter', 'today');
            } else if (dateRange === 'yesterday') {
                // Yesterday (calendar day)
                params.append('time_filter', 'yesterday');
            } else {
                // Other values are in days
                params.append('days', dateRange);
            }
        }

        if (categoryId !== 'all') params.append('category_id', categoryId);
        if (priorityId !== 'all') params.append('priority_id', priorityId);
        if (statusId !== 'all') params.append('status_id', statusId);
        if (unitFilter !== 'all') params.append('unit', unitFilter);

        // Fetch filtered data
        fetch('/api/analytics/issues?' + params.toString())
            .then(response => response.json())
            .then(data => {
                issuesData = data;
                updateDashboard(issuesData);
            })
            .catch(error => console.error('Error fetching filtered issues data:', error));
    }

    function resetFilters() {
        document.getElementById('date-range').value = 'all';
        document.getElementById('category-filter').value = 'all';
        document.getElementById('priority-filter').value = 'all';
        document.getElementById('status-filter').value = 'all';
        document.getElementById('unit-filter').value = 'all';

        fetchIssuesData();
    }

    function updateDashboard(data) {
        updateStatCards(data);
        createTimeChart(data);
        createTodayChart(data);
        createCategoryChart(data);
        createIssueTypesChart(data);
        createPriorityChart(data);
        createStatusChart(data);
        createCostChart(data);
        createUnitsByCostChart(data);
        createUnitHeatmap(data);
    }

    function updateStatCards(data) {
        // Update stat cards with calculated values
        document.getElementById('total-issues').textContent = data.length;

        const openIssues = data.filter(issue =>
            issue.status_name === 'Pending' ||
            issue.status_name === 'In Progress'
        ).length;
        document.getElementById('open-issues').textContent = openIssues;

        const resolvedIssues = data.filter(issue =>
            issue.status_name === 'Resolved'
        ).length;
        document.getElementById('resolved-issues').textContent = resolvedIssues;

        // Calculate total cost, filtering out null/undefined values
        const validCosts = data.filter(issue => issue.cost !== null && issue.cost !== undefined);
        let totalCost = 0;
        if (validCosts.length > 0) {
            totalCost = validCosts.reduce((sum, issue) => sum + Number(issue.cost), 0);
        }
        document.getElementById('total-cost').textContent = 'RM' + totalCost.toFixed(2);
    }

    function createTimeChart(data) {
        const ctx = document.getElementById('issues-over-time-chart').getContext('2d');

        // Destroy previous chart if exists
        if (timeChart) timeChart.destroy();

        // Group issues by month
        const issuesByMonth = {};
        data.forEach(issue => {
            const date = new Date(issue.date_added);
            const monthYear = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}`;

            if (!issuesByMonth[monthYear]) {
                issuesByMonth[monthYear] = {
                    total: 0,
                    byPriority: {
                        'High': 0,
                        'Medium': 0,
                        'Low': 0
                    }
                };
            }

            issuesByMonth[monthYear].total += 1;

            // Group by priority
            if (issue.priority_name) {
                issuesByMonth[monthYear].byPriority[issue.priority_name] += 1;
            }
        });

        // Sort months chronologically
        const months = Object.keys(issuesByMonth).sort();

        // Prepare datasets
        const highPriorityData = months.map(month => issuesByMonth[month].byPriority['High']);
        const mediumPriorityData = months.map(month => issuesByMonth[month].byPriority['Medium']);
        const lowPriorityData = months.map(month => issuesByMonth[month].byPriority['Low']);

        // Create chart
        timeChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: months.map(month => {
                    const [year, monthNum] = month.split('-');
                    return `${monthNum}/${year}`;
                }),
                datasets: [
                    {
                        label: 'High Priority',
                        data: highPriorityData,
                        borderColor: '#dc3545',
                        backgroundColor: 'rgba(220, 53, 69, 0.1)',
                        tension: 0.1,
                        fill: true
                    },
                    {
                        label: 'Medium Priority',
                        data: mediumPriorityData,
                        borderColor: '#fd7e14',
                        backgroundColor: 'rgba(253, 126, 20, 0.1)',
                        tension: 0.1,
                        fill: true
                    },
                    {
                        label: 'Low Priority',
                        data: lowPriorityData,
                        borderColor: '#28a745',
                        backgroundColor: 'rgba(40, 167, 69, 0.1)',
                        tension: 0.1,
                        fill: true
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Monthly Issues Trend',
                        font: {
                            size: 16
                        }
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false
                    },
                    legend: {
                        position: 'top'
                    }
                },
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Month'
                        }
                    },
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Number of Issues'
                        }
                    }
                }
            }
        });
    }

    function createTodayChart(data) {
        const ctx = document.getElementById('issues-today-chart').getContext('2d');

        // Destroy previous chart if exists
        if (todayChart) todayChart.destroy();

        // Get today's date in Malaysia timezone (set to midnight)
        // This is important because your backend seems to use Malaysia timezone
        const today = new Date();
        today.setHours(0, 0, 0, 0);

        // Create hours array (0-23)
        const hoursLabels = Array.from({ length: 24 }, (_, i) => i);

        // Initialize data structure for hourly issues
        const issuesByHour = {};
        hoursLabels.forEach(hour => {
            issuesByHour[hour] = 0;
        });

        // Filter for today's issues and group by hour
        data.forEach(issue => {
            // Parse the ISO date string directly
            const issueDateUTC = new Date(issue.date_added);

            // Convert to Malaysia time (UTC+8)
            // Create a function that converts UTC to Malaysia timezone
            const convertToMalaysiaTime = (utcDate) => {
                const malaysiaDate = new Date(utcDate);
                // Malaysia is UTC+8, so add 8 hours to UTC time
                malaysiaDate.setHours(malaysiaDate.getHours() + 8);
                return malaysiaDate;
            };

            const issueDateMalaysia = convertToMalaysiaTime(issueDateUTC);

            // Check if it's today in Malaysia timezone
            const issueDayMalaysia = new Date(issueDateMalaysia);
            issueDayMalaysia.setHours(0, 0, 0, 0);

            const todayMalaysia = new Date();
            todayMalaysia.setHours(0, 0, 0, 0);

            if (issueDayMalaysia.getTime() === todayMalaysia.getTime()) {
                // Get hour in Malaysia time
                const hourMalaysia = issueDateMalaysia.getHours();
                issuesByHour[hourMalaysia] += 1;
            }
        });

        // Prepare dataset
        const issuesData = hoursLabels.map(hour => issuesByHour[hour]);

        // Create chart
        todayChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: hoursLabels.map(hour => `${hour.toString().padStart(2, '0')}:00`),
                datasets: [
                    {
                        label: 'Total Issues',
                        data: issuesData,
                        borderColor: '#4169E1',
                        backgroundColor: 'rgba(65, 105, 225, 0.1)',
                        tension: 0.1,
                        fill: true,
                        borderWidth: 2
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Today\'s Issues by Hour (Malaysia Time)',
                        font: {
                            size: 16
                        }
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                        callbacks: {
                            title: function(tooltipItems) {
                                return 'Hour: ' + tooltipItems[0].label;
                            }
                        }
                    },
                    legend: {
                        position: 'top'
                    }
                },
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Hour of Day (Malaysia Time)'
                        },
                        grid: {
                            display: true
                        }
                    },
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Number of Issues'
                        },
                        suggestedMin: 0,
                        suggestedMax: 4,
                        ticks: {
                            stepSize: 1
                        }
                    }
                }
            }
        });
    }

    function createCategoryChart(data) {
        const ctx = document.getElementById('issues-by-category-chart').getContext('2d');

        // Destroy previous chart if exists
        if (categoryChart) categoryChart.destroy();

        // Group issues by category
        const issuesByCategory = {};
        data.forEach(issue => {
            if (issue.category_name) {
                if (!issuesByCategory[issue.category_name]) {
                    issuesByCategory[issue.category_name] = 0;
                }
                issuesByCategory[issue.category_name] += 1;
            }
        });

        // Prepare data for chart
        const categories = Object.keys(issuesByCategory);
        const categoryData = categories.map(cat => issuesByCategory[cat]);

        // Use the specific color scheme for this chart
        const categoryColors = [
            'rgba(129, 130, 200, 0.7)', // Purple (#8182c8)
            'rgba(243, 199, 113, 0.7)', // Gold (#f3c771)
            'rgba(129, 166, 227, 0.7)', // Light Blue (#81a6e3)
            'rgba(146, 208, 181, 0.7)', // Mint Green (#92d0b5)
            'rgba(182, 224, 127, 0.7)', // Light Green (#b6e07f)
            'rgba(232, 234, 119, 0.7)', // Yellow (#e8ea77)
            'rgba(239, 147, 103, 0.7)', // Orange (#ef9367)
            'rgba(243, 122, 119, 0.7)', // Coral (#f37a77)
            'rgba(108, 110, 163, 0.7)', // Deep Purple (#6c6ea3)
            'rgba(44, 71, 97, 0.7)'     // Navy (#2c4761)
        ];

        // Make sure we have enough colors by repeating if necessary
        const backgroundColors = [];
        for (let i = 0; i < categories.length; i++) {
            backgroundColors.push(categoryColors[i % categoryColors.length]);
        }

        // Create horizontal bar chart
        categoryChart = new Chart(ctx, {
            type: 'bar', // Still use 'bar' type
            data: {
                labels: categories,
                datasets: [{
                    label: 'Number of Issues',
                    data: categoryData,
                    backgroundColor: backgroundColors,
                    borderWidth: 1
                }]
            },
            options: {
                indexAxis: 'y', // This makes the bars horizontal
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Issues by Category',
                        font: {
                            size: 16
                        }
                    },
                    legend: {
                        display: false
                    }
                },
                scales: {
                    x: { // This was 'y' in vertical chart
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Number of Issues'
                        }
                    }
                }
            }
        });
    }

    function createIssueTypesChart(data) {
        const ctx = document.getElementById('issue-types-chart').getContext('2d');

        // Destroy previous chart if exists
        if (issueTypesChart) issueTypesChart.destroy();

        // Group issues by issue_item_name
        const issuesByType = {};
        data.forEach(issue => {
            if (issue.issue_item_name) {
                if (!issuesByType[issue.issue_item_name]) {
                    issuesByType[issue.issue_item_name] = 0;
                }
                issuesByType[issue.issue_item_name] += 1;
            }
        });

        // Sort issue types by count and take top 10
        const sortedTypes = Object.entries(issuesByType)
            .sort((a, b) => b[1] - a[1])
            .slice(0, 10);

        const issueTypes = sortedTypes.map(item => item[0]);
        const typeCounts = sortedTypes.map(item => item[1]);

        // Use the same color scheme as the category chart
        const typeColors = [
            'rgba(129, 130, 200, 0.7)', // Purple (#8182c8)
            'rgba(243, 199, 113, 0.7)', // Gold (#f3c771)
            'rgba(129, 166, 227, 0.7)', // Light Blue (#81a6e3)
            'rgba(146, 208, 181, 0.7)', // Mint Green (#92d0b5)
            'rgba(182, 224, 127, 0.7)', // Light Green (#b6e07f)
            'rgba(232, 234, 119, 0.7)', // Yellow (#e8ea77)
            'rgba(239, 147, 103, 0.7)', // Orange (#ef9367)
            'rgba(243, 122, 119, 0.7)', // Coral (#f37a77)
            'rgba(108, 110, 163, 0.7)', // Deep Purple (#6c6ea3)
            'rgba(44, 71, 97, 0.7)'     // Navy (#2c4761)
        ];

        // Create donut chart
        issueTypesChart = new Chart(ctx, {
            type: 'doughnut',
            data: {
                labels: issueTypes,
                datasets: [{
                    data: typeCounts,
                    backgroundColor: typeColors.slice(0, issueTypes.length),
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Top 10 Issue Types',
                        font: {
                            size: 16
                        }
                    },
                    legend: {
                        position: 'right',
                        labels: {
                            boxWidth: 12,
                            font: {
                                size: 11
                            }
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const label = context.label || '';
                                const value = context.raw || 0;
                                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                const percentage = Math.round((value / total) * 100);
                                return `${label}: ${value} (${percentage}%)`;
                            }
                        }
                    }
                },
                cutout: '50%'
            }
        });
    }

    function createPriorityChart(data) {
        const ctx = document.getElementById('issues-by-priority-chart').getContext('2d');

        // Destroy previous chart if exists
        if (priorityChart) priorityChart.destroy();

        // Group issues by priority
        const issuesByPriority = {
            'High': 0,
            'Medium': 0,
            'Low': 0,
            'Unspecified': 0
        };

        data.forEach(issue => {
            if (issue.priority_name) {
                issuesByPriority[issue.priority_name] += 1;
            } else {
                issuesByPriority['Unspecified'] += 1;
            }
        });

        // Create chart
        priorityChart = new Chart(ctx, {
            type: 'pie',
            data: {
                labels: Object.keys(issuesByPriority),
                datasets: [{
                    data: Object.values(issuesByPriority),
                    backgroundColor: [
                        '#dc3545', // High - Red
                        '#fd7e14', // Medium - Orange
                        '#28a745', // Low - Green
                        '#6c757d'  // Unspecified - Gray
                    ]
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Issues by Priority',
                        font: {
                            size: 16
                        }
                    },
                    legend: {
                        position: 'top'
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const label = context.label || '';
                                const value = context.raw || 0;
                                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                const percentage = Math.round((value / total) * 100);
                                return `${label}: ${value} (${percentage}%)`;
                            }
                        }
                    }
                }
            }
        });
    }

    function createStatusChart(data) {
        const ctx = document.getElementById('issues-by-status-chart').getContext('2d');

        // Destroy previous chart if exists
        if (statusChart) statusChart.destroy();

        // Group issues by status
        const issuesByStatus = {};
        data.forEach(issue => {
            if (issue.status_name) {
                if (!issuesByStatus[issue.status_name]) {
                    issuesByStatus[issue.status_name] = 0;
                }
                issuesByStatus[issue.status_name] += 1;
            }
        });

        // Predefined colors for statuses
        const statusColors = {
            'Pending': '#ffc107',      // Warning/Yellow
            'In Progress': '#17a2b8',  // Info/Blue
            'Resolved': '#28a745',     // Success/Green
            'Rejected': '#dc3545'      // Danger/Red
        };

        // Prepare data for chart
        const statuses = Object.keys(issuesByStatus);
        const statusData = statuses.map(status => issuesByStatus[status]);
        const colors = statuses.map(status => statusColors[status] || '#6c757d'); // Default gray

        // Create chart
        statusChart = new Chart(ctx, {
            type: 'doughnut',
            data: {
                labels: statuses,
                datasets: [{
                    data: statusData,
                    backgroundColor: colors
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Issues by Status',
                        font: {
                            size: 16
                        }
                    },
                    legend: {
                        position: 'top'
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const label = context.label || '';
                                const value = context.raw || 0;
                                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                const percentage = Math.round((value / total) * 100);
                                return `${label}: ${value} (${percentage}%)`;
                            }
                        }
                    }
                }
            }
        });
    }

    function createCostChart(data) {
            const ctx = document.getElementById('cost-analysis-chart').getContext('2d');

            // Destroy previous chart if exists
            if (costChart) costChart.destroy();

            // Filter out issues without cost data
            const issuesWithCost = data.filter(issue =>
                issue.cost !== null &&
                issue.cost !== undefined &&
                issue.category_name
            );

            // Group costs by category
            const costByCategory = {};

            issuesWithCost.forEach(issue => {
                if (!costByCategory[issue.category_name]) {
                    costByCategory[issue.category_name] = 0;
                }

                costByCategory[issue.category_name] += Number(issue.cost);
            });

            // Prepare data for chart
            const categories = Object.keys(costByCategory);
            const totalCostData = categories.map(cat => costByCategory[cat]);

            // Create chart
            costChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: categories,
                    datasets: [
                        {
                            label: 'Total Cost(RM)',
                            data: totalCostData,
                            backgroundColor: 'rgba(255, 99, 132, 0.5)',
                            borderColor: 'rgba(255, 99, 132, 1)',
                            borderWidth: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Cost Analysis by Category',
                            font: {
                                size: 16
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Total Cost (RM)'
                            }
                        }
                    }
                }
            });
        }


    // Helper function to generate colors
    function generateColors(count) {
        const baseColors = [
            'rgba(255, 99, 132, 0.7)',
            'rgba(54, 162, 235, 0.7)',
            'rgba(255, 206, 86, 0.7)',
            'rgba(75, 192, 192, 0.7)',
            'rgba(153, 102, 255, 0.7)',
            'rgba(255, 159, 64, 0.7)',
            'rgba(199, 199, 199, 0.7)',
            'rgba(83, 102, 255, 0.7)',
            'rgba(40, 159, 169, 0.7)',
            'rgba(210, 111, 140, 0.7)'
        ];

        let colors = [];
        for (let i = 0; i < count; i++) {
            colors.push(baseColors[i % baseColors.length]);
        }

        return colors;
    }


    function createUnitsByCostChart(data) {
        const ctx = document.getElementById('units-by-cost-chart').getContext('2d');

        // Destroy previous chart if exists
        if (window.unitsByCostChart) window.unitsByCostChart.destroy();

        // Filter out issues without cost data
        const issuesWithCost = data.filter(issue =>
            issue.cost !== null &&
            issue.cost !== undefined &&
            issue.unit
        );

        // Group costs by unit
        const costByUnit = {};

        issuesWithCost.forEach(issue => {
            if (!costByUnit[issue.unit]) {
                costByUnit[issue.unit] = 0;
            }

            costByUnit[issue.unit] += Number(issue.cost);
        });

        // Sort units by cost and take top 10
        const sortedUnits = Object.entries(costByUnit)
            .sort((a, b) => b[1] - a[1])
            .slice(0, 10);

        const units = sortedUnits.map(item => item[0]);
        const costs = sortedUnits.map(item => item[1]);

        // Create horizontal bar chart
        window.unitsByCostChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: units,
                datasets: [{
                    label: 'Total Cost (RM)',
                    data: costs,
                    backgroundColor: 'rgba(54, 162, 235, 0.5)',
                    borderColor: 'rgba(54, 162, 235, 1)',
                    borderWidth: 1
                }]
            },
            options: {
                indexAxis: 'y',  // This makes the chart horizontal
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Top Units by Total Cost',
                        font: {
                            size: 16
                        }
                    },
                    legend: {
                        display: true,
                        position: 'top'
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return `Total Cost: RM${context.raw.toFixed(2)}`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Total Cost (RM)'
                        }
                    }
                }
            }
        });
    }


    function createUnitHeatmap(data) {
        const ctx = document.getElementById('unit-heatmap-chart').getContext('2d');

        // Destroy previous chart if exists
        if (unitHeatmapChart) unitHeatmapChart.destroy();

        // Extract unique units and categories
        const uniqueUnits = [...new Set(data.map(issue => issue.unit))].filter(Boolean);
        const uniqueCategories = [...new Set(data.map(issue => issue.category_name))].filter(Boolean);

        // Sort units alphabetically
        uniqueUnits.sort();

        // Create a mapping of issue counts by unit and category
        const issueCountsByUnitAndCategory = {};

        // Initialize with zero values
        uniqueUnits.forEach(unit => {
            issueCountsByUnitAndCategory[unit] = {};
            uniqueCategories.forEach(category => {
                issueCountsByUnitAndCategory[unit][category] = 0;
            });
        });

        // Count issues by unit and category
        data.forEach(issue => {
            if (issue.unit && issue.category_name) {
                issueCountsByUnitAndCategory[issue.unit][issue.category_name]++;
            }
        });

        // Create custom plugin for cell colors
        const cellColorsPlugin = {
            id: 'cellColors',
            beforeDatasetsDraw: (chart) => {
                const {ctx, chartArea, scales} = chart;
                const {top, bottom, left, right, width, height} = chartArea;
                const countMax = Math.max(...Object.values(issueCountsByUnitAndCategory)
                    .flatMap(categoryMap => Object.values(categoryMap)));

                // Define color scheme based on the image colors
                const getColorForValue = (value) => {
                    if (value === 0) return 'rgba(240, 240, 240, 1)'; // Light gray for zero

                    // Normalize value between 0 and 1
                    const normalizedValue = value / countMax;

                    // Define color stops based on the image colors
                    const colorStops = [
                        { pos: 0.0, color: [156, 99, 66] },   // #9c6342 (brown red)
                        { pos: 0.2, color: [132, 157, 43] },  // #849d2b (olive green)
                        { pos: 0.4, color: [237, 209, 97] },  // #edb161 (tan/gold)
                        { pos: 0.6, color: [82, 126, 45] },   // #527e0d (forest green)
                        { pos: 0.8, color: [196, 39, 39] },   // #ec272b (bright red)
                        { pos: 1.0, color: [175, 35, 35] }    // #af2323 (dark red)
                    ];

                    // Find the appropriate color based on value
                    let lowerIndex = 0;
                    for (let i = 0; i < colorStops.length - 1; i++) {
                        if (normalizedValue >= colorStops[i].pos && normalizedValue <= colorStops[i+1].pos) {
                            lowerIndex = i;
                            break;
                        }
                    }

                    const lowerColor = colorStops[lowerIndex].color;
                    const upperColor = colorStops[lowerIndex + 1].color;
                    const lowerPos = colorStops[lowerIndex].pos;
                    const upperPos = colorStops[lowerIndex + 1].pos;

                    // Interpolate between the two colors
                    const t = (normalizedValue - lowerPos) / (upperPos - lowerPos);
                    const r = Math.round(lowerColor[0] + t * (upperColor[0] - lowerColor[0]));
                    const g = Math.round(lowerColor[1] + t * (upperColor[1] - lowerColor[1]));
                    const b = Math.round(lowerColor[2] + t * (upperColor[2] - lowerColor[2]));

                    return `rgba(${r}, ${g}, ${b}, 1)`;
                };

                // Draw colored cells
                for (let i = 0; i < uniqueUnits.length; i++) {
                    for (let j = 0; j < uniqueCategories.length; j++) {
                        const unit = uniqueUnits[i];
                        const category = uniqueCategories[j];
                        const value = issueCountsByUnitAndCategory[unit][category];

                        const x = scales.x.getPixelForValue(j);
                        const y = scales.y.getPixelForValue(i);
                        const cellWidth = scales.x.getPixelForValue(j+1) - x;
                        const cellHeight = scales.y.getPixelForValue(i+1) - y;

                        // Fill cell with color based on value
                        ctx.fillStyle = getColorForValue(value);
                        ctx.fillRect(x, y, cellWidth, cellHeight);

                        // Add text showing the value
                        ctx.fillStyle = value > countMax * 0.7 ? 'white' : 'black';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.font = '16px Arial'; // Larger font
                        ctx.fillText(value, x + cellWidth / 2, y + cellHeight / 2);
                    }
                }
            }
        };

        // Prepare data for Chart.js
        // We'll create a dataset for each category

        const datasets = uniqueCategories.map((category, index) => {
            return {
                label: category,
                // For each unit, get the value for this category
                data: uniqueUnits.map(unit => issueCountsByUnitAndCategory[unit][category]),
                backgroundColor: 'rgba(0, 0, 0, 0)' // Transparent background
            };
        });

        // Create the heatmap
        unitHeatmapChart = new Chart(ctx, {
            type: 'bar',
            plugins: [cellColorsPlugin],
            data: {
                labels: uniqueUnits, // This puts units on the y-axis
                datasets: datasets   // Categories will be displayed as column headers
            },
            options: {
                indexAxis: 'y',
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },

                    tooltip: {
                        callbacks: {
                            title: function(tooltipItems) {
                                return `Unit: ${tooltipItems[0].label}`;
                            },
                            label: function(context) {
                                // Get the category from the dataset label instead of dataIndex
                                const categoryIndex = context.datasetIndex;
                                const category = uniqueCategories[categoryIndex];
                                const unit = context.label;
                                const value = issueCountsByUnitAndCategory[unit][category];
                                return `${category}: ${value} issues`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        stacked: true,
                        display: true,
                        grid: {
                            display: false
                        },
                        ticks: {
                            display: false
                        },
                        title: {
                            display: false
                        }
                    },
                    y: {
                        stacked: true,
                        grid: {
                            display: false
                        },
                        ticks: {
                            font: {
                                size: 14 // Larger y-axis labels
                            }
                        },
                        title: {
                            display: true,
                            text: 'Unit',
                            font: {
                                size: 16,
                                weight: 'bold'
                            }
                        }
                    }
                },
                layout: {
                    padding: {
                        top: 70,

                    }
                }
            }
        });

        // Add custom title
        // Add custom title
        // Add custom title
        const originalDraw = unitHeatmapChart.draw;
        unitHeatmapChart.draw = function() {
            originalDraw.apply(this, arguments);

            // Draw header row with category names rotated
            const {ctx, chartArea, scales} = this;
            ctx.save();
            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px Arial'; // Larger font for headers

            // Draw category names across the top
            uniqueCategories.forEach((category, index) => {
                const x = scales.x.getPixelForValue(index) + (scales.x.getPixelForValue(index+1) - scales.x.getPixelForValue(index))/2;
                const y = -20; // Move text even higher up

                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(-Math.PI/4); // Adjust rotation
                ctx.textAlign = 'right';

                // Position text further from axis
                ctx.fillText(category, 0, 30); 
                ctx.restore();
            });

            ctx.restore();
        };
    }
</script>


<script>
    // Javascript of "Replacement Item" Tab

    // Define the color scheme for replacement charts
    const replacementColors = [
        '#8182c8', // Purple
        '#f3c771', // Gold
        '#81a6e3', // Light Blue
        '#92d0b5', // Mint Green
        '#b6e07f', // Light Green
        '#e8ea77', // Yellow
        '#ef9367', // Orange
        '#f37a77', // Coral
        '#6c6ea3', // Deep Purple
        '#2c4761'  // Navy
    ];

    let replacementPieChart, replacementTreemapChart;

    // Function to populate the unit dropdown for replacements
    function populateReplacementUnitDropdown() {
        fetch('/api/get_units')
            .then(response => response.json())
            .then(units => {
                console.log('Units data:', units);

                const unitSelect = document.getElementById('replacement-unit');

                // Add "All Units" option if it doesn't exist
                if (unitSelect.options.length === 0) {
                    const defaultOption = document.createElement('option');
                    defaultOption.value = 'all';
                    defaultOption.textContent = 'All Units';
                    unitSelect.appendChild(defaultOption);
                }

                // Clear existing options except the "All Units" option
                while (unitSelect.options.length > 1) {
                    unitSelect.remove(1);
                }

                units.forEach(unit => {
                    const option = document.createElement('option');
                    option.value = unit.id;
                    option.textContent = unit.unit_number;
                    unitSelect.appendChild(option);
                });

                // Debug the unit dropdown after populating
                debugUnitDropdown();
            })
            .catch(error => {
                console.error('Error loading units:', error);
                initEmptyCharts();
            });
    }

    // Helper function to get unit number by ID
    function getUnitNumberById(unitId) {
        const unitSelect = document.getElementById('replacement-unit');
        if (!unitSelect) return null;

        for (let i = 0; i < unitSelect.options.length; i++) {
            if (unitSelect.options[i].value === unitId) {
                return unitSelect.options[i].textContent;
            }
        }
        return null;
    }

    // Debug function to log unit dropdown contents
    function debugUnitDropdown() {
        const unitSelect = document.getElementById('replacement-unit');
        if (!unitSelect) return;

        console.log('Unit dropdown contents:');
        for (let i = 0; i < unitSelect.options.length; i++) {
            console.log(`Option ${i}: value=${unitSelect.options[i].value}, text=${unitSelect.options[i].textContent}`);
        }
    }

    // Function to populate category dropdown from the actual database
    function populateReplacementCategoryDropdown() {
        // Fetch categories from the server using the existing data
        const categorySelect = document.getElementById('replacement-category');

        // Add "All Categories" option if it doesn't exist
        if (categorySelect.options.length === 0) {
            const defaultOption = document.createElement('option');
            defaultOption.value = 'all';
            defaultOption.textContent = 'All Categories';
            categorySelect.appendChild(defaultOption);
        }

        // Clear existing options except the "All Categories" option
        while (categorySelect.options.length > 1) {
            categorySelect.remove(1);
        }

        // Get unique categories from the issues data
        fetch('/api/analytics/issues')
            .then(response => response.json())
            .then(data => {
                // Extract unique categories with their IDs
                const categories = new Map(); // Use Map to store name->id mapping
                data.forEach(issue => {
                    if (issue.category_name && issue.category_id) {
                        categories.set(issue.category_name, issue.category_id);
                    }
                });

                // Add to dropdown
                Array.from(categories.entries())
                    .sort((a, b) => a[0].localeCompare(b[0]))
                    .forEach(([name, id]) => {
                        const option = document.createElement('option');
                        option.value = id; // Use the actual category_id
                        option.textContent = name;
                        categorySelect.appendChild(option);
                    });
            })
            .catch(error => {
                console.error('Error loading categories:', error);
                initEmptyCharts();
            });
    }

    // Function to fetch replacement data from the server with fixed unit filter
    function fetchReplacementData() {
        // Get filter parameters
        const timePeriod = document.getElementById('replacement-time-period')?.value || 'all';
        const unitId = document.getElementById('replacement-unit')?.value || 'all';
        const categoryId = document.getElementById('replacement-category')?.value || 'all';

        // Build query parameters
        let params = new URLSearchParams();

        // Handle different date ranges with the same format as your other analytics functions
        if (timePeriod !== 'all') {
            if (timePeriod === 'hour') {
                params.append('time_filter', 'hour');
            } else if (timePeriod === 'today') {
                params.append('time_filter', 'today');
            } else if (timePeriod === 'yesterday') {
                params.append('time_filter', 'yesterday');
            } else {
                // Other values are in days
                params.append('days', timePeriod);
            }
        }

        // Add category filter if selected
        if (categoryId !== 'all') {
            params.append('category_id', categoryId);
        }

        // First fetch all issues
        fetch('/api/analytics/issues?' + params.toString())
            .then(response => response.json())
            .then(data => {
                // If unit filter is active, filter issues by unit_id manually
                let filteredData = data;

                if (unitId !== 'all') {
                    // This is where our fix is - manually filter by unit_id
                    filteredData = data.filter(issue => {
                        // Check if the issue has a unit_id or we can match by unit name
                        return (issue.unit_id && issue.unit_id == unitId) ||
                               // Get the unit number from the dropdown
                               (issue.unit === getUnitNumberById(unitId));
                    });

                    console.log(`Filtered ${data.length} issues to ${filteredData.length} for unit ID ${unitId}`);
                }

                processReplacementData(filteredData);
            })
            .catch(error => {
                console.error('Error fetching replacement data:', error);
                initEmptyCharts();
            });
    }

    // Process the API data for replacement visualization
    function processReplacementData(data) {
        console.log('Processing data for replacements');

        // Filter for issues with issue_item_id (these are our "replacement items")
        // Also filter for issues that have a type.name of "Replace" if available
        const replacementData = data.filter(issue => {
            const isItemDefined = issue.issue_item_id && issue.issue_item_name;
            const isReplacementType = issue.type_name === 'Replace'; // Check for type "Replace"

            // If type name is available, use it as a filter, otherwise just check for item definition
            if (issue.type_name) {
                return isItemDefined && isReplacementType;
            } else {
                return isItemDefined;
            }
        });

        console.log('Filtered to', replacementData.length, 'replacement items');

        // Transform data for our visualization
        const transformedData = replacementData.map(issue => ({
            item: issue.issue_item_name || "Unknown Item",
            cost: parseFloat(issue.cost) || 0,
            unit: issue.unit || "Unknown Unit",
            category: issue.category_name || 'Uncategorized',
            date: issue.date_added
        }));

        // Update the charts with the transformed data
        updateReplacementCharts(transformedData);
    }

    // Initialize empty charts to ensure they always appear
    function initEmptyCharts() {
        // Default data for empty charts
        const defaultData = {
            labels: ['No Data Available'],
            datasets: [{
                data: [1],
                backgroundColor: ['#e9ecef'],
                borderWidth: 0
            }]
        };

        // Initialize the pie chart
        const pieCtx = document.getElementById('replacement-pie-chart')?.getContext('2d');
        if (pieCtx) {
            // Destroy previous chart if exists
            if (replacementPieChart) replacementPieChart.destroy();

            replacementPieChart = new Chart(pieCtx, {
                type: 'pie',
                data: defaultData,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            enabled: false
                        }
                    }
                }
            });
        }

        // Initialize the treemap chart
        const treeCtx = document.getElementById('replacement-treemap-chart')?.getContext('2d');
        if (treeCtx) {
            // Destroy previous chart if exists
            if (replacementTreemapChart) replacementTreemapChart.destroy();

            replacementTreemapChart = new Chart(treeCtx, {
                type: 'bar',
                data: defaultData,
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { display: false },
                        y: { display: false }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: { enabled: false }
                    }
                }
            });
        }

        // Update the analytics cards with zeros
        document.getElementById('total-replacement-cost').textContent = 'RM0.00';
        document.getElementById('total-replacement-items').textContent = '0';
    }

    // Function to update the replacement charts
    function updateReplacementCharts(data) {
        console.log('Updating charts with', data.length, 'items');

        // Calculate total cost and item count
        let totalCost = 0;
        const itemCounts = {};

        data.forEach(item => {
            totalCost += parseFloat(item.cost || 0);

            if (!itemCounts[item.item]) {
                itemCounts[item.item] = 0;
            }
            itemCounts[item.item]++;
        });

        // Update the analytics cards
        document.getElementById('total-replacement-cost').textContent = 'RM' + totalCost.toFixed(2);
        document.getElementById('total-replacement-items').textContent = data.length;

        // Check if we have any data
        if (data.length === 0) {
            // Display empty charts
            initEmptyCharts();
            return;
        }

        // Prepare data for pie chart
        const pieItems = Object.keys(itemCounts);
        const pieCounts = pieItems.map(item => itemCounts[item]);

        // Create pie chart
        createReplacementPieChart(pieItems, pieCounts);

        // Create treemap
        createReplacementTreemapChart(itemCounts);
    }

    // Create the replacement pie chart
    function createReplacementPieChart(labels, data) {
        const ctx = document.getElementById('replacement-pie-chart');
        if (!ctx) return; // Safety check

        // Destroy previous chart if exists
        if (replacementPieChart) replacementPieChart.destroy();

        // Generate colors for all items
        const colors = labels.map((_, index) => replacementColors[index % replacementColors.length]);

        replacementPieChart = new Chart(ctx, {
            type: 'pie',
            data: {
                labels: labels,
                datasets: [{
                    data: data,
                    backgroundColor: colors,
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'right',
                        labels: {
                            boxWidth: 12,
                            font: {
                                size: 11
                            }
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const label = context.label || '';
                                const value = context.raw || 0;
                                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                const percentage = Math.round((value / total) * 100);
                                return `${label}: ${value} (${percentage}%)`;
                            }
                        }
                    }
                }
            }
        });
    }

    // Create a treemap visualization (using a modified horizontal bar chart)
    function createReplacementTreemapChart(itemCounts) {
        const ctx = document.getElementById('replacement-treemap-chart');
        if (!ctx) return; // Safety check

        // Destroy previous chart if exists
        if (replacementTreemapChart) replacementTreemapChart.destroy();

        // Sort items by count for better visualization
        const sortedItems = Object.entries(itemCounts)
            .sort((a, b) => b[1] - a[1])
            .slice(0, 10); // Show top 10 items

        const labels = sortedItems.map(item => item[0]);
        const data = sortedItems.map(item => item[1]);

        // Generate colors for all items
        const colors = labels.map((_, index) => replacementColors[index % replacementColors.length]);

        replacementTreemapChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: labels,
                datasets: [{
                    label: 'Count',
                    data: data,
                    backgroundColor: colors,
                    borderWidth: 1
                }]
            },
            options: {
                indexAxis: 'y', // Horizontal bar chart
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    title: {
                        display: false
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return `Quantity: ${context.raw}`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Quantity'
                        }
                    },
                    y: {
                        title: {
                            display: false
                        }
                    }
                }
            }
        });
    }

    // Initialize the replacement tab
    function initReplacementTab() {
        // First initialize empty charts to ensure something is always displayed
        initEmptyCharts();

        // Then populate dropdowns with real data
        populateReplacementUnitDropdown();
        populateReplacementCategoryDropdown();

        // Finally fetch initial data
        fetchReplacementData();
    }

    // Add this to your existing document ready function or at the end of your script
    document.addEventListener('DOMContentLoaded', function() {
        // Add event listeners for the replacement tab
        document.querySelector('.chart-tab[data-tab="replacement-item"]')?.addEventListener('click', function() {
            document.querySelectorAll('.chart-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

            this.classList.add('active');
            const contentElement = document.getElementById('replacement-item-content');
            if (contentElement) contentElement.classList.add('active');

            // Initialize tab data if not already initialized
            if (!replacementPieChart) {
                initReplacementTab();
            }
        });

        // Add event listeners for the replacement filter buttons
        document.getElementById('apply-replacement-filters')?.addEventListener('click', function() {
            const unitId = document.getElementById('replacement-unit')?.value || 'all';
            console.log('Applying filters with unit ID:', unitId);
            debugUnitDropdown();
            fetchReplacementData();
        });

        document.getElementById('reset-replacement-filters')?.addEventListener('click', function() {
            console.log('Resetting filters...');
            // Reset filters
            if (document.getElementById('replacement-time-period'))
                document.getElementById('replacement-time-period').value = 'all';
            if (document.getElementById('replacement-unit'))
                document.getElementById('replacement-unit').value = 'all';
            if (document.getElementById('replacement-category'))
                document.getElementById('replacement-category').value = 'all';

            // Fetch all data
            fetchReplacementData();
        });
    });
</script>
{% endblock %}